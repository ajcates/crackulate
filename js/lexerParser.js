// File Overview: js/lexerParser.js
// This file contains the logic for the first two stages of processing user input:
// Lexical Analysis (Lexing) and Syntactic Analysis (Parsing).
//
// 1. Token Types Definition:
//    - `TokenTypes`: An object that defines various categories of tokens
//      (e.g., NUMBER, VARIABLE, OPERATOR). This provides a standardized way
//      to classify parts of the input string.
//
// 2. Lexer Function (`lexer`):
//    - Purpose: To take a raw input string (a line from the editor) and break it
//      down into a sequence of tokens. Each token is an object with a `type`
//      (from `TokenTypes`) and a `value`.
//    - How it works: It iterates through the input string character by character,
//      identifying patterns that correspond to different token types (numbers,
//      variables, operators, parentheses, line references like #1, assignment operator =).
//      Whitespace is ignored.
//
// 3. Parser Class (`Parser`):
//    - Purpose: To take the sequence of tokens generated by the lexer and construct
//      an Abstract Syntax Tree (AST). An AST is a hierarchical tree-like data structure
//      that represents the syntactic structure of the input expression or assignment.
//    - How it works: It uses a recursive descent parsing strategy. It has methods
//      to parse different parts of the grammar (assignments, expressions, terms, factors).
//      - `parse()`: The main entry point, determines if the input is an assignment or an expression.
//      - `parseAssignment()`: Parses `variable = expression`.
//      - `parseExpression()`: Parses additions and subtractions (lower precedence).
//      - `parseTerm()`: Parses multiplications and divisions (higher precedence).
//      - `parseFactor()`: Parses numbers, variables, line references, or parenthesized expressions.
//    - The parser consumes tokens one by one and builds up the AST nodes. If it encounters
//      an unexpected token or structure, it throws an error.
//
// The `TokenTypes`, `lexer` function, and `Parser` class are exported for use by other
// modules (primarily `domUtils.js`, which orchestrates the processing of editor input).

// **Token Types Definition**
// An enumeration of the different types of tokens that the lexer can identify.
const TokenTypes = {
  NUMBER: 'NUMBER',       // e.g., 3.14, 42
  VARIABLE: 'VARIABLE',   // e.g., x, myVar
  OPERATOR: 'OPERATOR',   // e.g., +, -, *, /
  ASSIGN: 'ASSIGN',       // e.g., =
  LPAREN: 'LPAREN',       // e.g., (
  RPAREN: 'RPAREN',       // e.g., )
  LINEREF: 'LINEREF'      // e.g., #1, #23 (references to line results)
};

// **Lexer Function**
// Converts an input string into an array of tokens.
// `input`: The string to tokenize (e.g., "x = 5 + #1").
// Returns an array of token objects, e.g., [{type: VARIABLE, value: 'x'}, {type: ASSIGN, value: '='}, ...].
function lexer(input) {
  const tokens = []; // Array to store the generated tokens.
  let i = 0; // Current position in the input string.

  while (i < input.length) {
    let char = input[i];

    // Skip whitespace characters.
    if (/\s/.test(char)) {
      i++;
      continue;
    }

    // Tokenize Line References (e.g., #12)
    if (char === '#') {
      i++; // Consume the '#'
      let num = '';
      while (i < input.length && /[0-9]/.test(input[i])) {
        num += input[i];
        i++;
      }
      if (num === '') throw new Error('Invalid line reference: missing line number after #');
      tokens.push({ type: TokenTypes.LINEREF, value: parseInt(num) });
      continue;
    }

    // Tokenize Numbers (integers and decimals)
    if (/[0-9]/.test(char) || char === '.') {
      let num = '';
      let hasDecimal = char === '.';
      while (i < input.length && (/[0-9]/.test(input[i]) || (input[i] === '.' && !hasDecimal))) {
        if (input[i] === '.') hasDecimal = true;
        num += input[i];
        i++;
      }
      // Ensure that a standalone "." is not tokenized as a number, or handle it as an error.
      if (num === '.') throw new Error('Invalid number: standalone decimal point.');
      tokens.push({ type: TokenTypes.NUMBER, value: parseFloat(num) });
      continue;
    }

    // Tokenize Variables (alphanumeric, starting with a letter)
    if (/[a-zA-Z]/.test(char)) {
      let varName = '';
      while (i < input.length && /[a-zA-Z0-9]/.test(input[i])) {
        varName += input[i];
        i++;
      }
      tokens.push({ type: TokenTypes.VARIABLE, value: varName });
      continue;
    }

    // Tokenize Operators (+, -, *, /)
    if (['+', '-', '*', '/'].includes(char)) {
      tokens.push({ type: TokenTypes.OPERATOR, value: char });
      i++;
      continue;
    }

    // Tokenize Assignment Operator (=)
    if (char === '=') {
      tokens.push({ type: TokenTypes.ASSIGN, value: char });
      i++;
      continue;
    }

    // Tokenize Left Parenthesis (()
    if (char === '(') {
      tokens.push({ type: TokenTypes.LPAREN, value: char });
      i++;
      continue;
    }

    // Tokenize Right Parenthesis ())
    if (char === ')') {
      tokens.push({ type: TokenTypes.RPAREN, value: char });
      i++;
      continue;
    }

    // If the character is not recognized, it's a lexical error.
    throw new Error(`Unexpected character: ${char}`);
    // i++; // Original code had i++ here, which would skip the error char. Better to throw.
  }
  return tokens;
}

// **Parser Class**
// Takes an array of tokens from the lexer and builds an Abstract Syntax Tree (AST).
class Parser {
  constructor(tokens) {
    this.tokens = tokens; // The array of tokens to parse.
    this.index = 0;       // The current position in the tokens array.
  }

  // Helper method: Returns the current token without consuming it.
  peek() { return this.tokens[this.index]; }
  // Helper method: Returns the current token and advances the index.
  consume() { return this.tokens[this.index++]; }
  // Helper method: Checks if there are more tokens to parse.
  hasNext() { return this.index < this.tokens.length; }

  // Main parsing method. Determines if the token stream represents an assignment or an expression.
  // This implements a simple form of predictive parsing based on the first few tokens.
  parse() {
    if (!this.peek()) return null; // Handle empty input or no tokens.

    // Check for assignment: VARIABLE ASSIGN ...
    // Look ahead one token to see if an ASSIGN token follows a VARIABLE token.
    if (this.peek().type === TokenTypes.VARIABLE &&
        this.index + 1 < this.tokens.length && // Ensure there is a next token
        this.tokens[this.index + 1].type === TokenTypes.ASSIGN) {
      return this.parseAssignment();
    }
    // Otherwise, assume it's an expression.
    return this.parseExpression();
  }

  // Parses an assignment statement (e.g., "variable = expression").
  // Expected structure: VARIABLE ASSIGN expression
  parseAssignment() {
    const variable = this.consume().value; // Consume VARIABLE token.
    this.consume(); // Consume ASSIGN token ('=').
    const expression = this.parseExpression(); // Parse the expression on the right-hand side.
    // Return an AST node representing the assignment.
    return { type: 'assignment', variable, expression };
  }

  // Parses an expression (handles addition and subtraction).
  // Grammar: expression -> term ( ( '+' | '-' ) term )*
  // This means an expression is a term, optionally followed by + or - and another term, repeated.
  parseExpression() {
    let left = this.parseTerm(); // Parse the first term (left-hand side of potential +/-).

    // While the next token is an addition or subtraction operator:
    while (this.peek() && this.peek().type === TokenTypes.OPERATOR && ['+', '-'].includes(this.peek().value)) {
      const op = this.consume().value; // Consume the operator token.
      const right = this.parseTerm(); // Parse the term on the right-hand side.
      // Create a binary operation AST node and update `left` for left-associativity.
      left = { type: 'binary', operator: op, left, right };
    }
    return left; // Return the resulting AST (or single term if no operators).
  }

  // Parses a term (handles multiplication and division).
  // Grammar: term -> factor ( ( '*' | '/' ) factor )*
  // This means a term is a factor, optionally followed by * or / and another factor, repeated.
  parseTerm() {
    let left = this.parseFactor(); // Parse the first factor.

    // While the next token is a multiplication or division operator:
    while (this.peek() && this.peek().type === TokenTypes.OPERATOR && ['*', '/'].includes(this.peek().value)) {
      const op = this.consume().value; // Consume the operator token.
      const right = this.parseFactor(); // Parse the factor on the right-hand side.
      // Create a binary operation AST node and update `left`.
      left = { type: 'binary', operator: op, left, right };
    }
    return left; // Return the resulting AST (or single factor if no operators).
  }

  // Parses a factor (the most basic elements of an expression).
  // Grammar: factor -> NUMBER | VARIABLE | LINEREF | LPAREN expression RPAREN
  parseFactor() {
    const token = this.consume(); // Consume the current token.
    if (!token) throw new Error('Unexpected end of input: Expected a factor (number, variable, #ref, or parenthesized expression).');

    if (token.type === TokenTypes.NUMBER) {
      return { type: 'number', value: token.value }; // AST node for a number.
    }
    if (token.type === TokenTypes.VARIABLE) {
      return { type: 'variable', name: token.value }; // AST node for a variable.
    }
    if (token.type === TokenTypes.LINEREF) {
      return { type: 'lineref', line: token.value }; // AST node for a line reference.
    }
    if (token.type === TokenTypes.LPAREN) {
      // If it's an opening parenthesis, parse the inner expression.
      const expr = this.parseExpression();
      // Expect a closing parenthesis.
      if (!this.peek() || this.consume().type !== TokenTypes.RPAREN) {
        throw new Error('Expected closing parenthesis )');
      }
      return expr; // Return the AST of the parenthesized expression.
    }
    // If the token is not a recognized factor type, it's a syntax error.
    throw new Error(`Unexpected token: ${token.value} (type: ${token.type}). Expected a number, variable, line reference, or '('.`);
  }
}

// Export the TokenTypes, lexer function, and Parser class for use in other modules.
export { TokenTypes, lexer, Parser };
