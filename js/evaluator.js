// File Overview: js/evaluator.js
// This file defines the `evaluate` function, which is responsible for processing an
// Abstract Syntax Tree (AST) generated by the parser and calculating a numerical result.
// The evaluator recursively traverses the AST, performing operations based on the type
// of each node. It handles:
// - Numbers: Returns their literal value.
// - Variables: Looks up their value in the current `scope`. Throws an error if undefined.
// - Line References (#N): Looks up the result of a previous line. Throws an error for invalid references.
// - Binary Operations (+, -, *, /): Recursively evaluates left and right operands, then performs the operation.
//   Handles division by zero by returning NaN.
// - Assignments (=): Evaluates the expression on the right-hand side and updates the `scope`
//   with the new variable value. Returns the assigned value.
// The `evaluate` function takes the AST node, the current variable scope, an array of
// results from previous lines (for line references), and the current line number as input.

// **Evaluator Function**
// Takes an Abstract Syntax Tree (AST) node, a scope object (for variable storage),
// an array of line results (for line references), and the current line index.
// Recursively evaluates the AST to produce a numerical result or perform an assignment.
function evaluate(ast, scope, lineResults, currentLine) {
  // Base case: if the AST node is null or undefined (e.g., from an empty expression), return null.
  if (!ast) return null;

  // Handle number literals: return their value directly.
  if (ast.type === 'number') return ast.value;

  // Handle variables: look up the variable name in the current scope.
  if (ast.type === 'variable') {
    if (!(ast.name in scope)) {
      // If the variable is not found in the scope, it's an error.
      throw new Error(`Undefined variable: ${ast.name}`);
    }
    return scope[ast.name]; // Return the variable's value.
  }

  // Handle line references (e.g., #2 refers to the result of line 2).
  if (ast.type === 'lineref') {
    const lineIndex = ast.line - 1; // Convert 1-based line number to 0-based array index.
    // Validate the line reference:
    // - Must not refer to the current line or future lines (circular dependency).
    // - Must be within the bounds of the `lineResults` array.
    // - The referenced line must have a valid result (not undefined).
    if (lineIndex >= currentLine || lineIndex < 0 || lineResults[lineIndex] === undefined) {
      throw new Error(`Invalid line reference: #${ast.line}`);
    }
    const refValue = lineResults[lineIndex];
    // Check if the referenced line resulted in an error.
    if (refValue === 'e') {
      throw new Error(`Cannot reference an error: #${ast.line}`);
    }
    // Convert the referenced result (which might be a string) to a floating-point number.
    return parseFloat(refValue);
  }

  // Handle binary operations (e.g., addition, subtraction).
  if (ast.type === 'binary') {
    // Recursively evaluate the left and right operands of the binary expression.
    const left = evaluate(ast.left, scope, lineResults, currentLine);
    const right = evaluate(ast.right, scope, lineResults, currentLine);
    // Perform the operation based on the operator type.
    switch (ast.operator) {
      case '+': return left + right;
      case '-': return left - right;
      case '*': return left * right;
      case '/':
        // Handle division by zero: return NaN (Not a Number).
        // The updateResults function in domUtils.js will typically display this as '0' or handle it.
        return right === 0 ? NaN : left / right;
      default:
        // If the operator is unknown, it's an error.
        throw new Error(`Unknown operator: ${ast.operator}`);
    }
  }

  // Handle assignment operations (e.g., x = 10).
  if (ast.type === 'assignment') {
    // Recursively evaluate the expression on the right-hand side of the assignment.
    const value = evaluate(ast.expression, scope, lineResults, currentLine);
    // Store the result in the scope, associating it with the variable name.
    // This modifies the `scope` object directly, which is intended so that
    // subsequent lines in the same evaluation run can access this new/updated variable.
    scope[ast.variable] = value;
    return value; // The result of an assignment expression is the assigned value itself.
  }

  // If the AST node type is unknown or not handled, it's an error.
  throw new Error('Unknown AST node type');
}

// Export the evaluate function for use by other modules (specifically domUtils.js).
export { evaluate };
